# Service Locator Pattern 

## 趣旨

サービスを実装する具象クラスにユーザーをカップリングすることなく、サービスへアクセスするグローバルポイントを提供する。




## パターン

サービスクラスは、一連のオペレーションに対する抽象的なインターフェイスを定義する。具体的なサービスプロバイダは、このインターフェイスを実装する。別のサービスロケータは、適切なプロバイダを見つけることでサービスへのアクセスを提供し、プロバイダの具象型とそれを見つけるためのプロセスの両方を隠します。



## いつ使うか


あるコードが必要とするオブジェクトにアクセスするためにグローバルなメカニズムを使用する代わりに、まずそのオブジェクトを渡すことを検討してください。これは非常にシンプルで、カップリングは完全に明白です。これで、ほとんどのニーズはカバーできるだろう。

しかし......手動でオブジェクトを受け渡すことがありがた迷惑であったり、積極的にコードを読みにくくする場合があります。ロギングやメモリ管理など、モジュールのパブリックAPIに含まれるべきではないシステムもある。レンダリングコードのパラメータはレンダリングに関係するものであるべきで、ログのようなものではありません。

同様に、他のシステムは、基本的に単一な性質を持つ設備を表します。ゲームには、おそらく1つのオーディオデバイスやディスプレイシステムしかないでしょう。これは環境のアンビエントなプロパティであり、深くネストされた1つの呼び出しのために、それを10層のメソッドで配管することは、コードを不必要に複雑にしています。

このような場合、このパターンが役に立ちます。これから説明するように、このパターンはSingletonパターンより柔軟で、より設定しやすいいとことして機能します。うまく使えば、わずかな実行時コストでコードベースをより柔軟にすることができる。

サービスロケータの難点は、依存関係（2つのコード間のちょっとした結合）を取り込み、実行時まで配線を延期することです。これによって柔軟性が得られるが、その代償として、コードを読んでも依存関係を理解することが難しくなる。

## Tips


Service Locatorパターンは、多くの点でSingletonパターンと非常に似ているので、両方を検討して、どちらが自分のニーズに合っているかを判断する価値がある。

Unityエンジンでは、このパターンとコンポーネントパターンを組み合わせ、GetComponent()メソッドで使用しています。
